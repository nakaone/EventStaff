<!DOCTYPE html><html lang="ja">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <meta http-equiv="Content-Script-Type" content="text/javascript">
  <script src="../js/crypto-js.3.3.0.min.js"></script>
  <title>script test</title>
  <style>
    /* =========================================================
    ========================================================= */
    html {font-size:10pt;  /* 基本となる文字サイズ */}
    body {box-sizing: border-box;}  /* 枠線は要素サイズに含める */
    div {margin:0px;padding:0px;}
  </style>
  <style> input { width: 500px; } </style>
</head>

<body>
  <div id="crypto">
    <h1>指定文字列の暗号化/復号</h1>
    <p><label>暗号鍵</label><input type="text" name="key" onchange="convert()" value="Oct.22,2022" /></p>
    <p><label>文字列</label><input type="text" name="str" onchange="convert()" /></p>
    <div class="passPhrase"></div>
    <div class="str"></div>
    <div class="utf8_plain"></div>
    <div class="encrypted"></div>
    <div class="encryptResult"></div>
    <div class="decrypted"></div>
    <div class="txt_dexrypted"></div>
    <div id="result"></div>
  </div>
</body>
<script type="text/javascript">
/*
  AES暗号化 (javascript)
  https://chakkari.org/blog/2020/05/03/aes-encrypt-with-javascript/
*/
const api = 'https://script.google.com/macros/s/AKfycby_3JoBIesmrm9G-CG4RzTh8bjilPR2rHaNkN5LRKTbLgZfhxy9zIT2to6Ra9d8CfceQA/exec';
const convert = () => {

  const v = {};

  // パスフレーズ（暗号鍵）
  v.passPhrase = document.querySelector('#crypto input[name="key"]').value;

  // 暗号化・復号化対象文字列
  v.str = document.querySelector('#crypto input[name="str"]').value;
  v.utf8_plain = CryptoJS.enc.Utf8.parse(v.str);

  // 暗号化
  v.encrypted = CryptoJS.AES.encrypt( v.utf8_plain, v.passPhrase );  // Obj
  v.encryptResult = v.encrypted.toString(); // toString()で文字列化

  // 復号化
  v.decrypted = CryptoJS.AES.decrypt( v.str , v.passPhrase );
  v.txt_dexrypted = v.decrypted.toString(CryptoJS.enc.Utf8);

  for( let x in v ){
    console.log(x,v[x]);
    const e = document.querySelector('#crypto .'+x);
    e.innerHTML = '<p style="color:red">_1 : _2</p>'.replace('_1',x).replace('_2',v[x]);
    e.innerHTML += '<p>type : _</p>'.replace('_',whichType(v[x]));
    e.innerHTML += '<p>length : _</p>'.replace('_',v[x].length);
    try {
      e.innerHTML += '<p>json : _</p>'.replace('_',JSON.stringify(v[x]));
    } catch(e) {
      //console.error(e);
    }
  }

}

const whichType = (arg = undefined) => {
  return arg === undefined ? 'undefined'
   : Object.prototype.toString.call(arg).match(/^\[object\s(.*)\]$/)[1];
}

class cipher {  // 変数をAES暗号化文字列に変換

  constructor(passPhrase){
    this.passPhrase = passPhrase;
  }

  encrypt(arg){
    const str = JSON.stringify(arg);
    console.log('cipher.encript start.\ntype='+whichType(arg)+'\n'+str);

    //const utf8_plain = CryptoJS.enc.Utf8.parse(str);
    const encrypted = CryptoJS.AES.encrypt( str, this.passPhrase );  // Obj
    // crypto-jsで複合化するとMalformed UTF-8 data になった件
    // https://zenn.dev/naonao70/articles/a2f7df87f9f736
    const encryptResult = CryptoJS.enc.Base64
      .stringify(CryptoJS.enc.Latin1.parse(encrypted.toString()));

    console.log("cipher.encript end.\n"+encryptResult);
    return encryptResult;
  }

  decrypt(arg){
    console.log('cipher.decrypt start.\n'+arg);
    const decodePath = decodeURIComponent(arg);
    const data = CryptoJS.enc.Base64
      .parse(decodePath.toString()).toString(CryptoJS.enc.Latin1);
    const bytes = CryptoJS.AES.decrypt(data, this.passPhrase)
      .toString(CryptoJS.enc.Utf8)

    let rv = null;
    try {
      rv = JSON.parse(bytes);
    } catch(e) {
      rv = bytes;
    } finally {
      console.log('cipher.decrypt end.\ntype='+whichType(rv)+'\n',rv);
      return rv;
    }

    /*const decrypted = CryptoJS.AES.decrypt( arg , this.passPhrase );
    const txt_dexrypted = decrypted.toString(CryptoJS.enc.Utf8);
    return txt_dexrypted;*/
  }
}

// 以下 cipher 用テスト
const cipherTestData = [0,'abc',true,[1,2,3],{a:10,b:20},new Date()];
const passPhrase = 'Oct.22,2022';
const cipherTest = () => {
  for( let x in cipherTestData ){
    const o = new cipher(passPhrase);
    const e = o.encrypt(cipherTestData[x]);
    //console.log('encrypt',cipherTestData[x],e,whichType(e));
    const d = o.decrypt(e);
    //console.log('decrypt',cipherTestData[x],d,whichType(d));
    //const j = JSON.parse(d);
    //console.log('json',cipherTestData[x],j,whichType(j));
  }
}

const doGet = (func='post',data,callback) => {
  console.log("doGet start. ",func,data,callback);

  // GASに渡すデータを作成
  const cObj = new cipher(passPhrase);
  const postData = cObj.encrypt({func:func,data:data});
  console.log('postData('+whichType(postData)+' '+postData.length+')='+postData);

  // エンドポイントを作成
  const endpoint =  //GASのAPIのURL
    api + '?v=' + postData;
    //"https://script.google.com/macros/s/〜/exec"
    //.replace("〜",config.GASwebAPId)
    console.log('endpoint='+endpoint);

  // fetchのオプション指定
  const opt = {
    "method": "GET",
    "mode": "no-cors",
    //"Accept": "application/json",
    //"Content-Type": "application/x-www-form-urlencoded",
  }

  // GASからの返信を元にcallbackを呼び出し
  fetch(endpoint,opt)
  .then(response => {
    console.log('response',response);
    return response.json();
  }).then(r => callback(r));  // 成功した処理

  console.log("doGet end.");
}
const doGetTestData = [
  {from:'あ',to:'xyz',message:'じゅげむ'},
  //{from:'い',to:'え',message:'ふが'},
  //{from:'う',to:'/+!',message:'ほげ'},
  //{from:'abc',to:'-',message:'いくら丼'},
  //{from:'0123',to:'スタッフ',message:'食べたい'},
]
const doGetTest = () => {
  for( let i=0 ; i<doGetTestData.length ; i++ ){
    console.log(doGetTestData[i]);
    doGet('post',doGetTestData[i],r => {
      console.log('GAS result',r);
      const e = document.getElementById('result');
      e.innerHTML += '<p>' + r + '</p><hr />';
    });
  }
}

//cipherTest();
doGetTest();

</script>
</html>